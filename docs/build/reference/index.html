<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · Charon.jl</title><meta name="title" content="Reference · Charon.jl"/><meta property="og:title" content="Reference · Charon.jl"/><meta property="twitter:title" content="Reference · Charon.jl"/><meta name="description" content="Documentation for Charon.jl."/><meta property="og:description" content="Documentation for Charon.jl."/><meta property="twitter:description" content="Documentation for Charon.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Charon.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Charon.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../contents/">Table of contents</a></li><li><a class="tocitem" href="../guide/">Getting started</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#MCMCsampler"><span>MCMCsampler</span></a></li><li><a class="tocitem" href="#unpackposterior"><span>unpackposterior</span></a></li><li><a class="tocitem" href="#exactposterior"><span>exactposterior</span></a></li><li><a class="tocitem" href="#Charon-EigenExpansion-type"><span>Charon EigenExpansion type</span></a></li><li><a class="tocitem" href="#Internal,-non-exported-functions"><span>Internal, non-exported functions</span></a></li><li><a class="tocitem" href="#Extended-Julia-base-functions."><span>Extended Julia base functions.</span></a></li></ul></li><li><a class="tocitem" href="../allfunctions/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Jan-van-Waaij/Charon.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/main/docs/src/reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><p>Charon has three <a href="https://docs.julialang.org/en/v1/manual/modules/#Export-lists">exported</a> functions, <a href="#mcmcsampler">MCMCsampler</a>, <a href="#exactposterior">exactposterior</a> and <a href="#unpackposterior">unpackposterior</a>,  that can be used after typing </p><pre><code class="language-julia hljs">using Charon </code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Charon.Charon" href="#Charon.Charon"><code>Charon.Charon</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">module Charon</code></pre><p>This package provides functions to sample from the posterior. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L1-L5">source</a></section></article><h2 id="MCMCsampler"><a class="docs-heading-anchor" href="#MCMCsampler">MCMCsampler</a><a id="MCMCsampler-1"></a><a class="docs-heading-anchor-permalink" href="#MCMCsampler" title="Permalink"></a></h2><p>This is the MCMC sampler. It has seven methods.</p><p>Data formats:</p><p>You can input the data in four formats. </p><ol><li>With two (opened) (gzipped) files: a base count file, which is a CSV file where the first column are the number of derived reads, and the second column is the coverage, and a frequency file, which is a CSV file with one column, containing the frequencies. The data at line i in the base count file corresponds to the same locus as the data on line i of the frequency file.   </li><li>As an (opened) (gzipped) DICE file, or in the form of a <a href="https://dataframes.juliadata.org/">DataFrame</a>, also in DICE format. So the first column is the number of ancestral reads, the second column is the number of derived reads, the third column is the frequency in the anchor population, and the fourth column is the count of the number of loci where this combination of three numbers occur. </li><li>Or, by providing three vectors: <code>coverages</code>, <code>derivedreads</code>, <code>frequencies</code>, of length equal to the number of SNPs, where at locus <code>i</code>, there are <code>derivedreads[i]</code> derived reads, <code>coverages[i]</code> coverage and <code>frequencies[i]</code> frequency in the anchor population. </li><li>The third format is given with four vectors: <code>coverages</code>, <code>derivedreads</code>, <code>frequencies</code>, <code>counts</code>. This means that there are <code>counts[i]</code> loci with <code>coverages[i]</code> coverage, <code>derivedreads[i]</code> derived reads and frequency <code>frequencies[i]</code> in the anchor population.</li></ol><p>If you provide data in formats 1, 2, or 3, then the program will automatically convert it to format 4. </p><p>Parameters:</p><ul><li><code>nchains</code>, number of chains, which is a positive integer. If you want to run all your chains in parallel, start julia with number of threads equal to <code>nchains</code>. </li><li><code>nsteps</code> number of samples per chain, which is a positive integer. </li><li><code>prioronn</code> the prior on n, specified as a subtype of <code>DiscreteUnivariateDistribution</code> of the Distributions Julia package. Our implementation requires that <code>prioronn</code> has support on {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, because otherwise rounding errors will accumulate too much. </li><li><code>prioronτCτA</code> is the prior on (τC, τA), which allows for correlation between τC and τA. Its type is a subtype of ContinuousMultivariateDistribution. It should have support contained in [0,∞)x[0,∞). </li><li><code>prioronϵ</code> is the prior on ϵ. It should have support in [0, 0.5). It is a subtype of <code>ContinuousUnivariateDistribution</code> in the Distributions package. </li><li><code>coverages</code> a vector with coverages = ancestral reads + derived reads. Is a subtype of <code>AbstractVector{&lt;:Integer}</code>. All coverages should be non-negative integers, and at least one should be positive. </li><li><code>derivedreads</code> a vector of derived reads. Is a subtype of <code>AbstractVector{&lt;:Integer}</code>. All elements of the vector should be non-negative integers.</li><li><code>frequencies</code> a vector of frequencies. Is a subtype of AbstractVector{&lt;:Real}. Each frequency is between 0.0 and 1.0. At least one frequency should be strictly between 0.0 and 1.0 with corresponding positive coverage. </li><li><code>counts</code>, all elements should be non-negative. For each index, <code>counts[index]</code> indicates how many loci there are with <code>derivedreads[index]</code> derived reads, coverage <code>coverages[index]</code> and frequency <code>frequencies[index]</code>.  </li><li><code>df</code> a <a href="https://dataframes.juliadata.org/">DataFrame</a> from the DataFrames package in the DICE-2 format. So the first column should be the number of ancestral reads, the second column the number of derived reads, the third column the frequencies in the anchor population, and the fourth column the counts of how many times this particular combination of ancestral reads, derived reads and frequency occurs. </li><li><code>dicefile</code> is either an opened (gzipped) DICE file, or a path to a (gzipped) DICE file. </li></ul><p><a href="https://docs.julialang.org/en/v1/manual/functions/#Keyword-Arguments">Keyword parameters</a>. Keyword parameters should be given as keyword=value to the function, in case you want to set another value then the default. </p><ul><li><code>messages</code> is an integer. If <code>messages</code> is non-positive, no message will be printed. If <code>messages</code> is positive, every <code>messages</code> steps a message will be printed with the progress of the sampler. The default value is <code>nsteps÷100</code>, so every 1% progress a message is printed.  </li><li><code>scalingmessage</code> is either <code>true</code> (default) or <code>false</code>. If true, a message will be printed when the scaling constant changes. </li><li><code>header</code> is <code>nothing</code>, <code>true</code> (default) or <code>false</code>. Has the dicefile a header? If nothing, the software tries to determine whether the dicefile has a header. This works only when you provide a path to a file.</li></ul><p>The output is a vector with nchains items. Each item represents a chain. Each item is a tuple consisting of six columns, as described <a href="../guide/#output-mcmc-sampler">here</a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Charon.MCMCsampler" href="#Charon.MCMCsampler"><code>Charon.MCMCsampler</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MCMCsampler(nchains::Integer, nsteps::Integer, prioronn::DiscreteUnivariateDistribution, prioronτCτA::ContinuousMultivariateDistribution, prioronϵ::ContinuousUnivariateDistribution, coverages::AbstractVector{&lt;:Integer}, derivedreads::AbstractVector{&lt;:Integer}, frequencies::AbstractVector{&lt;:Real}, counts::AbstractVector{&lt;:Integer}, messages::Integer=nsteps÷100, scalingmessages::Bool=true)</code></pre><p>MCMC with simulated proposals. There are counts[i] loci with coverage coverages[i], derivedreads[i] derived alleles and frequency frequencies[i] in the anchor population. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L383-L387">source</a></section><section><div><pre><code class="language-julia hljs">MCMCsampler(nchains::Integer, nsteps::Integer, prioronn::DiscreteUnivariateDistribution, prioronτCτA::ContinuousMultivariateDistribution, prioronϵ::ContinuousUnivariateDistribution, coverages::AbstractVector{&lt;:Integer}, derivedreads::AbstractVector{&lt;:Integer}, frequencies::AbstractVector{&lt;:Real}, messages::Integer=nsteps÷100, scalingmessages::Bool=true)</code></pre><p>coverages[i] is the coverage, derivedreads[i] the number of derived reads and frequencies[i] the frequency of the derived allele in the anchor population at locus i. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L605-L609">source</a></section><section><div><pre><code class="language-julia hljs">MCMCsampler(nchains::Integer, nsteps::Integer, prioronn::DiscreteUnivariateDistribution, prioronτCτA::ContinuousMultivariateDistribution, prioronϵ::ContinuousUnivariateDistribution, df::AbstractDataFrame, messages::Integer=nsteps÷100, scalingmessages::Bool=true)</code></pre><p>df is a DataFrame (from the DataFrames package) in DICE 2-pop format: It should contain exactly four columns, the first one contains the number of ancestral reads, the second the number of derived reads, the third the frequency of the derived allele in the anchor population and the fourth the number of loci with exactly this combination of data. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L622-L626">source</a></section><section><div><pre><code class="language-julia hljs">MCMCsampler(nchains::Integer, nsteps::Integer, prioronn::DiscreteUnivariateDistribution, prioronτCτA::ContinuousMultivariateDistribution, prioronϵ::ContinuousUnivariateDistribution, dicefile::IO, messages::Integer=nsteps÷100, scalingmessages::Bool=true, header::Bool=true)</code></pre><p>dicefile is an opened CSV-file in DICE 2-pop format: It should contain exactly 4 columns, the first one contains the number of ancestral reads, the second the number of derived reads, the third the frequency of the derived allele in the anchor population and the fourth the number of loci with exactly this combination of data.</p><p>If you have Julia 1.3 or higher, and the file is a zipped file, open it using a zip decompressor:</p><pre><code class="language-julia hljs">using CodecZlib
dicefile = GzipDecompressorStream(open(&quot;path/to/your/file.csv.gz&quot;))</code></pre><p>With the named argument &quot;header&quot; one should indicate whether the CSV file has a header. The default is true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L636-L647">source</a></section><section><div><pre><code class="language-julia hljs">MCMCsampler(nchains::Integer, nsteps::Integer, prioronn::DiscreteUnivariateDistribution, prioronτCτA::ContinuousMultivariateDistribution, prioronϵ::ContinuousUnivariateDistribution, dicefile::AbstractString, messages::Integer=nsteps÷100, scalingmessages::Bool=true)</code></pre><p>dicefile is a (zipped) CSV-file in DICE 2-pop format: It should contain exactly four columns, the first one contains the number of ancestral reads, the second the number of derived reads, the third the frequency of the derived allele in the anchor population and the fourth the number of loci with exactly this combination of data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L654-L658">source</a></section><section><div><pre><code class="language-julia hljs">MCMCsampler(nchains::Integer, nsteps::Integer, prioronn::DiscreteUnivariateDistribution, prioronτCτA::ContinuousMultivariateDistribution, prioronϵ::ContinuousUnivariateDistribution, sedimentdata::AbstractString, frequencies::AbstractString, derivedreads::AbstractVector{&lt;:Integer}, frequencies::AbstractVector{&lt;:Real}; messages::Integer=nsteps÷100, scalingmessages::Bool=true, headersedimentdata::Union{Nothing, Bool}, headerfrequencies::Union{Nothing, Bool})</code></pre><p>sedimentdata is a path to a CSV file, where the first column are the derived reads, and the second column are the coverages. frequencies is a path to a CSV file with one column, containing frequencies of the anchor population. The number of rows of both files should be the same. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L665-L669">source</a></section><section><div><pre><code class="language-julia hljs">MCMCsampler(nchains::Integer, nsteps::Integer, prioronn::DiscreteUnivariateDistribution, prioronτCτA::ContinuousMultivariateDistribution, prioronϵ::ContinuousUnivariateDistribution, sedimentdata::DataFrame, frequencies::DataFrame; messages::Integer=nsteps÷100, scalingmessages::Bool=true)</code></pre><p>sedimentdata is a path to a DataFrame, where the first column are the derived reads, and the second column are the coverages. frequencies is a DataFrame with one column, containing frequencies of the anchor population. The number of rows of both files should be the same.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L676-L680">source</a></section></article><h2 id="unpackposterior"><a class="docs-heading-anchor" href="#unpackposterior">unpackposterior</a><a id="unpackposterior-1"></a><a class="docs-heading-anchor-permalink" href="#unpackposterior" title="Permalink"></a></h2><p>This function is used to build the unconditional posterior from the MCMC samples conditioned on n, as described in the paper. It has two methods. </p><p>Arguments:</p><ul><li><code>nsteps</code> is the number of MCMC samples, a positive integer. </li><li><code>chains</code> this the tuple that is the output of <code>MCMCsampler</code>. </li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Charon.unpackposterior" href="#Charon.unpackposterior"><code>Charon.unpackposterior</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unpackposterior(nsteps::Integer, chains::AbstractVector{&lt;:Tuple{AbstractVector{&lt;:Integer}, AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}, AbstractMatrix{Bool}, AbstractMatrix{&lt;:Real}}})</code></pre><p>Calculate the unconditional posterior from the output of MCMCsampler. <code>chains</code> is the output of the sampler, <code>nsteps</code> is the number of MCMC samples. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L689-L693">source</a></section></article><h2 id="exactposterior"><a class="docs-heading-anchor" href="#exactposterior">exactposterior</a><a id="exactposterior-1"></a><a class="docs-heading-anchor-permalink" href="#exactposterior" title="Permalink"></a></h2><p><code>exactposterior</code> is a function to calculate the posterior up to a fixed constant, only depending on the data, but not on the parameters. You can use this function for maximum posterior estimation. If you use uniform priors, you can use this function for maximum likelihood estimation over the support of the prior. <code>MCMCsampler</code> uses this function to find a good starting point for the sampler. It has two methods. </p><p>The posterior is calculated for each combination of parameters (n, τC, τA, ϵ) with n in <code>nrange</code>, τC in <code>τCrange</code>, τA in <code>τArange</code> and ϵ in <code>ϵrange</code>. So make sure that <code>length(nrange)*length(τCrange)*length(τArange)*length(ϵrange)</code> is not too large, as otherwise it will take a very long time and you might run out of memory. </p><p>Parameters:</p><ul><li><code>nrange</code> vector of n values. Subtype of AbstractVector{&lt;:Integer}. Should be a subset of {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}. </li><li><code>τCrange</code> vector of τC values. Subtype of AbstractVector{&lt;:Real}. All values should be non-negative. </li><li><code>τArange</code> vector of τA values. Subtype of AbstractVector{&lt;:Real}. All values should be non-negative. </li><li><code>ϵrange</code> vector of ϵ values. Is a subtype of AbstractVector{&lt;:Real}. All values should be non-negative and smaller than 0.5. </li><li><code>coverages</code> a vector with coverages = ancestral reads + derived reads. Is a subtype of <code>AbstractVector{&lt;:Integer}</code>. All coverages should be non-negative integers, and at least one should be positive.</li><li><code>uniquecoverages</code> should be equal to <code>unique(coverages)</code>.  </li><li><code>derivedreads</code> a vector of derived reads. Is a subtype of <code>AbstractVector{&lt;:Integer}</code>. All elements of the vector should be non-negative integers.</li><li><code>frequencies</code> a vector of frequencies. Is a subtype of AbstractVector{&lt;:Real}. Each frequency is between 0.0 and 1.0. At least one frequency should be strictly between 0.0 and 1.0 with corresponding positive coverage. </li><li><code>counts</code>, all elements should be non-negative. For each index, <code>counts[index]</code> indicates how many loci there are with <code>derivedreads[index]</code> derived reads, coverage <code>coverages[index]</code> and frequency <code>frequencies[index]</code>. </li></ul><p>Keyword argument. </p><ul><li><code>messages</code> is an integer. If <code>messages</code> is non-positive, no message will be printed. If <code>messages</code> is positive, every <code>messages</code> steps a message will be printed with the progress of the calculations. </li></ul><p>The output are 5 vectors: <code>ns, τCs, τAs, ϵs, logliks</code>, of each of length <code>length(n)*length(τCrange)*length(τArange)*length(ϵrange)</code>, where <code>logliks[index]</code> is the log likelihood, up to an additive constant, with parameters <code>ns[index]</code>, <code>τCs[index]</code>, <code>τAs[index]</code> and <code>ϵs[index]</code>. The additive constant only depends on the data, but not on the parameters. </p><h3 id="Maximum-posterior-estimation-(MAP-estimator)-and-maximum-likelihood-estimation"><a class="docs-heading-anchor" href="#Maximum-posterior-estimation-(MAP-estimator)-and-maximum-likelihood-estimation">Maximum posterior estimation (MAP estimator) and maximum likelihood estimation</a><a id="Maximum-posterior-estimation-(MAP-estimator)-and-maximum-likelihood-estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Maximum-posterior-estimation-(MAP-estimator)-and-maximum-likelihood-estimation" title="Permalink"></a></h3><p>Suppose you have results</p><pre><code class="language-julia hljs">ns, τCs, τAs, ϵs, logliks = exactposterior(args...) </code></pre><p>where <code>args</code> are your arguments (data and priors, etc.). Then you can calculate the index where the log likelihood is maximised:</p><pre><code class="language-julia hljs">i_max = argmax(logliks)</code></pre><p>So </p><pre><code class="nohighlight hljs">ns[i_max], τCs[i_max], τAs[i_max], ϵs[i_max]</code></pre><p>is the MAP estimator. If you provide uniform priors, then the MAP estimator is a maximum likelihood estimator, where you maximise over the support of the prior. </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Charon.exactposterior" href="#Charon.exactposterior"><code>Charon.exactposterior</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exactposterior(nrange::AbstractVector{&lt;:Integer}, τCrange::AbstractVector{&lt;:Real}, τArange::AbstractVector{&lt;:Real}, ϵrange::AbstractVector{&lt;:Real}, coverages::AbstractVector{&lt;:Integer}, uniquecoverages::AbstractVector{&lt;:Integer}, derivedreads::AbstractVector{&lt;:Integer}, frequencies::AbstractVector{&lt;:Real}, counts::AbstractVector{&lt;:Integer}, messages::Integer)</code></pre><p>Calculate the exact posterior up to a fixed unknown constant that depends on the data but does not depend on the parameters. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L282-L286">source</a></section><section><div><pre><code class="language-julia hljs">exactposterior(nrange::AbstractVector{&lt;:Integer}, τCrange::AbstractVector{&lt;:Real}, τArange::AbstractVector{&lt;:Real}, ϵrange::AbstractVector{&lt;:Real}, coverages::AbstractVector{&lt;:Integer}, derivedreads::AbstractVector{&lt;:Integer}, frequencies::AbstractVector{&lt;:Real}, messages::Integer=length(n)*length(τCrange)*length(τArange)*length(ϵrange)÷100)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L353-L355">source</a></section></article><h2 id="Charon-EigenExpansion-type"><a class="docs-heading-anchor" href="#Charon-EigenExpansion-type">Charon EigenExpansion type</a><a id="Charon-EigenExpansion-type-1"></a><a class="docs-heading-anchor-permalink" href="#Charon-EigenExpansion-type" title="Permalink"></a></h2><p>This type is not exported, but can be used after <code>using Charon: EigenExpansion</code>, or via <code>Charon.EigenExpansion</code>. It represents a matrix decomposition <span>$M=P*D*P^{-1}$</span>, where <span>$P$</span> is an invertible matrix with inverse <span>$P^{-1}$</span>, and <span>$D$</span> is a diagonal matrix. It is used to efficiently calculate the exponent of a matrix. </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Charon.EigenExpansion" href="#Charon.EigenExpansion"><code>Charon.EigenExpansion</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EigenExpansion{Q&lt;:AbstractMatrix{&lt;:Real}, R&lt;:Real, S&lt;:AbstractVector{R}, T&lt;:AbstractMatrix{&lt;:Real}}</code></pre><p>Representation of a matrix decomposition M=P<em>D</em>P^{-1}, where D is a diagonal matrix and P an invertible matrix with inverse Pinv. The fields are P, D and Pinv of types Q, Diagonal{R, S}, and T, respectively. </p><p>This decomposition can be used for fast matrix exponentiation, using that exp(M) = P<em>exp(D)</em>Pinv, and the fact that the exponent of a diagonal matrix is formed by exponentiating its diagonal elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L29-L35">source</a></section></article><h2 id="Internal,-non-exported-functions"><a class="docs-heading-anchor" href="#Internal,-non-exported-functions">Internal, non-exported functions</a><a id="Internal,-non-exported-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Internal,-non-exported-functions" title="Permalink"></a></h2><p>The following functions are not exported, and only available via <code>Charon.functionname</code>, or <code>using Charon: functionname</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Charon.calcloglik" href="#Charon.calcloglik"><code>Charon.calcloglik</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calcloglik(coverages::AbstractVector{&lt;:Integer}, derivedreads::AbstractVector{&lt;:Integer}, counts::AbstractVector{&lt;:Integer}, M::AbstractMatrix{&lt;:Real}, hvals::AbstractMatrix{&lt;:Real}, q::AbstractDict{&lt;:Tuple{Integer, Integer}, &lt;:AbstractVector{&lt;:Real}}, index::Integer)</code></pre><p>Calculate the log-likelihood at locus index. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L253-L257">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Charon.calcmatrix" href="#Charon.calcmatrix"><code>Charon.calcmatrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calcmatrix(τC::Real, τA::Real, Qꜜ::EigenExpansion, Q::EigenExpansion)</code></pre><p>Calculate the matrix <code>e^{Q*τ_A}e^{Qꜜτ_C}</code> as in Schraiber. Note that in general, for matrices, exp(A+B) ≠ exp(A)exp(B) (equality holds if and only if A and B commute, which is not the case for Q and Qꜜ). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L131-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Charon.filtervectorsandapplycountmap" href="#Charon.filtervectorsandapplycountmap"><code>Charon.filtervectorsandapplycountmap</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">filtervectorsandapplycountmap(coverages::AbstractVector{&lt;:Integer}, derivedreads::AbstractVector{&lt;:Integer}, frequencies::AbstractVector{&lt;:Real}, allowedindices::AbstractVector{Bool})</code></pre><p>This function does the following: coverages<em>filtered = coverages[allowedindices] derivedreads</em>filtered = derivedreads[allowedindices] frequencies_filtered = frequencies[allowedindices]</p><p>Next, it counts how many times (coverages<em>filtered[i], derivedreads</em>filtered[i], frequencies<em>filtered[i]) occurs, for all triples, and next returns four vectors (coverages</em>filtered<em>unique, derivedreads</em>filtered<em>unique, frequencies</em>filtered<em>unique, counts), where each triple (coverages</em>filtered<em>unique[i], derivedreads</em>filtered<em>unique[i], frequencies</em>filtered<em>unique[i]) is unique and occurs counts[i] times in zip(coverages</em>filtered, derivedreads<em>filtered, frequencies</em>filtered).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L183-L192">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Charon.logprobderivedreads!" href="#Charon.logprobderivedreads!"><code>Charon.logprobderivedreads!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">logprobderivedreads!(q::AbstractDict{&lt;:Tuple{Integer, Integer}, &lt;:AbstractVector{&lt;:Real}}, n::Integer, τC::Real, τA::Real, ϵ::Real, coverages::AbstractVector{&lt;:Integer}, uniquecoverages::AbstractVector{&lt;:Integer}, derivedreads::AbstractVector{&lt;:Integer}, counts::AbstractVector{&lt;:Integer}, Qꜜ::EigenExpansion, Q::EigenExpansion, binomialcoefficients::AbstractVector{&lt;:Integer}, hvals::AbstractMatrix{&lt;:Real})</code></pre><p>Calculate the log probability of the data, a.k.a. the likelihood. This function mutates q, which is a dictionary, and is used for intermediate calculations. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L162-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Charon.makeq" href="#Charon.makeq"><code>Charon.makeq</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">makeq(nmax::Integer, coverages::AbstractVector{&lt;:Integer}, derivedreads::AbstractVector{&lt;:Integer})</code></pre><p>Construct a vector of length nmax, where the n-th item is a dictionary with keys (coverages[i], derivedreads[i]) and values real vectors of length 2n+1. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L224-L228">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Charon.makeqfixedn" href="#Charon.makeqfixedn"><code>Charon.makeqfixedn</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">makeqfixedn(n::Integer, uniquecoveragesandderivedreads::AbstractVector{&lt;:Tuple{Integer, Integer}})</code></pre><p>Construct a dictionary with keys (coverages[i], derivedreads[i]) and values real vectors of length 2n+1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L207-L211">source</a></section><section><div><pre><code class="language-julia hljs">makeqfixedn(n::Integer, coverages::AbstractVector{&lt;:Integer}, derivedreads::AbstractVector{&lt;:Integer})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L215-L217">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Charon.makeQ" href="#Charon.makeQ"><code>Charon.makeQ</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">makeQ(n::Integer)</code></pre><p>Calculate the (2n+1)x(2n+1) tridiagonal matrix Q as in Schraiber 2018. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L105-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Charon.makeQꜜ" href="#Charon.makeQꜜ"><code>Charon.makeQꜜ</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">makeQꜜ(n::Integer)</code></pre><p>Calculate the (2n+1)x(2n+1) tridiagonal matrix Qꜜ as in Schraiber 2018.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L118-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Charon.preparedata" href="#Charon.preparedata"><code>Charon.preparedata</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">preparedata(n::Integer, frequencies::AbstractVector{&lt;:Real})</code></pre><p>Returns a named tuple (Qꜜ=Qꜜ, Q=Q, binomialcoefficients=binomialcoefficients, hvals=hvals), where  Qꜜ and Q are EigenExpansions of Qꜜ and Q (as in Schraiber 2018), respectively.  hvals is a (2n+1) x length(y) matrix of type SizedMatrix. SizedMatrix is used rather than SMatrix because this matrix is so large and  SMatrix is slow for large matrices. The matrix hvals is defined as hvals[k+1,i] = frequencies[i]^k*(1-frequencies[i])^(2n-k) (note that Julia has 1-based indexing). binomialcoefficients is a vector (of type SVector) containing the binomial coefficients 2n over k, k=0,...,2n.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L139-L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Charon.readcsvfile" href="#Charon.readcsvfile"><code>Charon.readcsvfile</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">readcsvfile(filename::AbstractString)</code></pre><p>Read CSV file and turn it into a DataFrame (from DataFrames package). It automatically detects whether the CSV file has a header. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L260-L264">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Charon.updateq!" href="#Charon.updateq!"><code>Charon.updateq!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">updateq!(q::AbstractDict{&lt;:Tuple{Integer, Integer}, &lt;:AbstractVector{&lt;:Real}}, n::Integer, ϵ::Real, uniquecoverages::AbstractVector{&lt;:Integer}, binomialcoefficients::AbstractVector{&lt;:Integer})</code></pre><p>Update the dictionary q, so that q[(R, d)][k+1] is the probability of d derived reads out of R when you have k derived alleles with n inidividuals and error rate ϵ. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L235-L239">source</a></section></article><h2 id="Extended-Julia-base-functions."><a class="docs-heading-anchor" href="#Extended-Julia-base-functions.">Extended Julia base functions.</a><a id="Extended-Julia-base-functions.-1"></a><a class="docs-heading-anchor-permalink" href="#Extended-Julia-base-functions." title="Permalink"></a></h2><p>I extended several Julia base functions to my custom EigenExpansion type. </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.exp" href="#Base.exp"><code>Base.exp</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exp(s::Real, F::EigenExpansion)</code></pre><p>Calculate e^(s*M) in a numerically efficient way. </p><p>If F=EigenExpansion(M), then exp(s<em>M)=exp(s, F)=F.P</em>exp(s<em>F.D)</em>F.Pinv, which makes  use of the fast implementation of exp for diagonal matrices (it is just the exponentiation of the diagonal elements).     </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L94-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.show" href="#Base.show"><code>Base.show</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.show(io::IO, mime::MIME{Symbol(&quot;text/plain&quot;)}, F::EigenExpansion{Q, R, S, T}) where {Q&lt;:AbstractMatrix{&lt;:Real}, R&lt;:Real, S&lt;:AbstractVector{R}, T&lt;:AbstractMatrix{&lt;:Real}}</code></pre><p>Pretty display of EigenExpansion types. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:==" href="#Base.:=="><code>Base.:==</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">==(E1::EigenExpansion, E2::EigenExpansion)</code></pre><p>Test whether E1 and E2 have the same decomposition P<em>D</em>P^(-1), so whether E1.P == E2.P, E1.D == E2.D and E1.Pinv == E2.Pinv.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L86-L90">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../guide/">« Getting started</a><a class="docs-footer-nextpage" href="../allfunctions/">Index »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.0 on <span class="colophon-date" title="Monday 12 May 2025 13:14">Monday 12 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
