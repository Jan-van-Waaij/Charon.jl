<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · Charon.jl</title><meta name="title" content="Reference · Charon.jl"/><meta property="og:title" content="Reference · Charon.jl"/><meta property="twitter:title" content="Reference · Charon.jl"/><meta name="description" content="Documentation for Charon.jl."/><meta property="og:description" content="Documentation for Charon.jl."/><meta property="twitter:description" content="Documentation for Charon.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Charon.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Charon.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../contents/">Table of contents</a></li><li><a class="tocitem" href="../guide/">Getting started</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#MCMCsampler"><span>MCMCsampler</span></a></li><li><a class="tocitem" href="#unpackposterior"><span>unpackposterior</span></a></li><li><a class="tocitem" href="#exactposterior"><span>exactposterior</span></a></li><li><a class="tocitem" href="#Charon-EigenExpansion-type"><span>Charon EigenExpansion type</span></a></li><li><a class="tocitem" href="#Internal,-non-exported-functions"><span>Internal, non-exported functions</span></a></li><li><a class="tocitem" href="#Extended-Julia-base-functions."><span>Extended Julia base functions.</span></a></li></ul></li><li><a class="tocitem" href="../allfunctions/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Jan-van-Waaij/Charon.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/main/docs/src/reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><p>Charon has three <a href="https://docs.julialang.org/en/v1/manual/modules/#Export-lists">exported</a> functions, <a href="#mcmcsampler">MCMCsampler</a>, <a href="#exactposterior">exactposterior</a> and <a href="#unpackposterior">unpackposterior</a>,  that can be used after typing </p><pre><code class="language-julia hljs">using Charon </code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Charon.Charon" href="#Charon.Charon"><code>Charon.Charon</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">module Charon</code></pre><p>This package provides an MCMC sampler and other functions to infer drift  times and the number of individuals from environmental DNA. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L1-L5">source</a></section></article><h2 id="MCMCsampler"><a class="docs-heading-anchor" href="#MCMCsampler">MCMCsampler</a><a id="MCMCsampler-1"></a><a class="docs-heading-anchor-permalink" href="#MCMCsampler" title="Permalink"></a></h2><p>This is the MCMC sampler. It has seven methods.</p><p>Data formats:</p><p>You can input the data in four formats. </p><ol><li>With two (opened) (gzipped) files: a base count file, which is a CSV file where the first column are the number of derived reads, and the second column is the coverage, and a frequency file, which is a CSV file with one column, containing the frequencies. The data at line i in the base count file corresponds to the same locus as the data on line i of the frequency file.   </li><li>As an (opened) (gzipped) DICE file, or in the form of a DataFrame, also in DICE format. So the first column is the number of ancestral reads, the second column is the number of derived reads, the third column is the frequency in the anchor population, and the fourth column is the count of the number of loci where this combination of three numbers occur. </li><li>Or, by providing three vectors: <code>coverages</code>, <code>derivedreads</code>, <code>frequencies</code>, of length equal to the number of SNPs, where at locus <code>i</code>, there are <code>derivedreads[i]</code> derived reads, <code>coverages[i]</code> coverage and <code>frequencies[i]</code> frequency in the anchor population. </li><li>The third format is given with four vectors: <code>coverages</code>, <code>derivedreads</code>, <code>frequencies</code>, <code>counts</code>. This means that there are <code>counts[i]</code> loci with <code>coverages[i]</code> coverage, <code>derivedreads[i]</code> derived reads and frequency <code>frequencies[i]</code> in the anchor population.</li></ol><p>If you provide data in formats 1, 2, or 3, then the program will automatically convert it to format 4. </p><p>Parameters:</p><ul><li><code>nchains</code>, number of chains, which is a positive integer. If you want to run all your chains in parallel, start julia with number of threads equal to <code>nchains</code>. </li><li><code>nsteps</code> number of samples per chain, which is a positive integer. </li><li><code>prioronn</code> the prior on n, specified as a subtype of <code>DiscreteUnivariateDistribution</code> of the Distributions Julia package. Our implementation requires that <code>prioronn</code> has support on {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, because otherwise rounding errors will accumulate too much. </li><li><code>prioronτCτA</code> is the prior on (τC, τA), which allows for correlation between τC and τA. Its type is a subtype of ContinuousMultivariateDistribution. It should have support contained in [0,∞)x[0,∞). </li><li><code>prioronϵ</code> is the prior on ϵ. It should have support in [0, 0.5). It is a subtype of <code>ContinuousUnivariateDistribution</code> in the Distributions package. </li><li><code>coverages</code> a vector with coverages = ancestral reads + derived reads. Is a subtype of <code>AbstractVector{&lt;:Integer}</code>. All coverages should be non-negative integers, and at least one should be positive. </li><li><code>derivedreads</code> a vector of derived reads. Is a subtype of <code>AbstractVector{&lt;:Integer}</code>. All elements of the vector should be non-negative integers.</li><li><code>frequencies</code> a vector of frequencies. Is a subtype of AbstractVector{&lt;:Real}. Each frequency is between 0.0 and 1.0. At least one frequency should be strictly between 0.0 and 1.0 with corresponding positive coverage. </li><li><code>counts</code>, all elements should be non-negative. For each index, <code>counts[index]</code> indicates how many loci there are with <code>derivedreads[index]</code> derived reads, coverage <code>coverages[index]</code> and frequency <code>frequencies[index]</code>.  </li><li><code>df</code> a DataFrame from the DataFrames package in the DICE-2 format. So the first column should be the number of ancestral reads, the second column the number of derived reads, the third column the frequencies in the anchor population, and the fourth column the counts of how many times this particular combination of ancestral reads, derived reads and frequency occurs. </li><li><code>dicefile</code> is either an opened (gzipped) DICE file, or a path to a (gzipped) DICE file. </li></ul><p><a href="https://docs.julialang.org/en/v1/manual/functions/#Keyword-Arguments">Keyword parameters</a>. Keyword parameters should be given as keyword=value to the function, in case you want to set another value then the default. </p><ul><li><code>messages</code> is an integer. If <code>messages</code> is non-positive, no message will be printed. If <code>messages</code> is positive, every <code>messages</code> steps a message will be printed with the progress of the sampler. The default value is <code>nsteps÷100</code>, so every 1% progress a message is printed.  </li><li><code>scalingmessage</code> is either <code>true</code> (default) or <code>false</code>. If true, a message will be printed when the scaling constant changes. </li><li><code>header</code> is <code>nothing</code>, <code>true</code> (default) or <code>false</code>. Has the dicefile a header? If nothing, the software tries to determine whether the dicefile has a header. This works only when you provide a path to a file.</li></ul><p>The output is a vector with nchains items. Each item represents a chain. Each item is a tuple consisting of six columns, as described <a href="../guide/#output-mcmc-sampler">here</a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Charon.MCMCsampler" href="#Charon.MCMCsampler"><code>Charon.MCMCsampler</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MCMCsampler(nchains::Integer, nsteps::Integer, prioronn::DiscreteUnivariateDistribution, prioronτCτA::ContinuousMultivariateDistribution, prioronϵ::ContinuousUnivariateDistribution, coverages::AbstractVector{&lt;:Integer}, derivedreads::AbstractVector{&lt;:Integer}, frequencies::AbstractVector{&lt;:Real}, counts::AbstractVector{&lt;:Integer}; messages::Integer=nsteps÷100, scalingmessages::Bool=true)</code></pre><p>The MCMC sampler as descriped in the article. Parameters:</p><p><strong>Number of chains and samples:</strong></p><ul><li><code>nchains</code> a positive integer. Indicates the number of chains. If you start Julia with <code>nchains</code> threads, then the chains are run in parallel. </li><li><code>nsteps</code> a positive number. The number of samples for each chain.</li></ul><p><strong>Prior</strong></p><ul><li><code>prioronn</code> the prior on n. </li><li><code>prioronτCτA</code> the prior on τC and τA. The sampler allows correlation in the prior between the parameters. </li><li><code>prioronϵ</code> the prior on ϵ.</li></ul><p><strong>Data</strong></p><ul><li><code>coverages</code> a vector of positive integers, the coverages. </li><li><code>derivedreads</code> a vector of non-negative integers, the number of derived reads. for each index <code>0 ≤ derivedreads[i] ≤ coverages[i]</code>. </li><li><code>frequencies</code> a vector of real number in the interval [0, 1]. For at least one index <code>i</code>, <code>coverages[i]&gt;0</code> and <code>0 &lt; frequencies[i] &lt; 1</code>.</li><li><code>counts</code> a vector with positive integers. For each index <code>counts[i]</code> indicates in how many loci there is coverage <code>coverages[i]</code>, <code>derivedreads[i]</code> derived reads and frequency <code>frequencies[i]</code>. </li></ul><p><strong>Keyword parameters</strong></p><ul><li><code>messages</code> an integer. If the integer is non-positive, no messages will be printed. If messages is positive, every <code>messages</code> steps, an update about the progress will be printed. The default value is <code>nsteps÷100</code>, so every 1% progress a message is printed. </li><li><code>scalingmessages</code> should the sampler print a message when the scaling constants change? The default value is true. </li></ul><p>Output:  The output is a vector of tuples. Each tuple represents a chain. Each tuple has the following elements: <code>nsample, τCsample, τAsample, ϵsample, accepted, logjointprob</code>. </p><ul><li><code>nsample</code> sample for the number of individuals. </li><li><code>τCsample</code> a nsample x maximum(prioronn) matrix, where the n-th column is the MCMC chain of τC conditioned on n individuals. </li><li><code>τAsample</code> same as τCsample but now for τA.</li><li><code>ϵsample</code> same as τCsample but now for ϵ.</li><li><code>accepted</code> a nsample x (maximum(prior)+1) matrix, where the first column indicates whether the proposal for n was accepted. The n+1-th column indicates whether the proposal for (τC,τA,ϵ) was accepted for the posterior conditioned on n. </li><li><code>logjointprob</code> a nsample x (maximum(prior)+1) matrix, where the first column is the log joint probability, up to a constant not depending on parameters, of the unconditioned posterior, and the n+1-th column is the log joint probability, up to a constant not depending on the parameters, of the posterior conditioned on n individuals. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L445-L473">source</a></section><section><div><pre><code class="language-julia hljs">MCMCsampler(nchains::Integer, nsteps::Integer, prioronn::DiscreteUnivariateDistribution, prioronτCτA::ContinuousMultivariateDistribution, prioronϵ::ContinuousUnivariateDistribution, coverages::AbstractVector{&lt;:Integer}, derivedreads::AbstractVector{&lt;:Integer}, frequencies::AbstractVector{&lt;:Real}; messages::Integer=nsteps÷100, scalingmessages::Bool=true)</code></pre><p>Same as the other method, except with data <code>coverages</code>, <code>derivedreads</code> and <code>frequencies</code>. This is the data of all loci, so at locus i, the coverage is <code>coverages[i]</code> with <code>derivedreads[i]</code> derived reads, and frequency <code>frequencies[i]</code> in the anchor population. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L691-L695">source</a></section><section><div><pre><code class="language-julia hljs">MCMCsampler(nchains::Integer, nsteps::Integer, prioronn::DiscreteUnivariateDistribution, prioronτCτA::ContinuousMultivariateDistribution, prioronϵ::ContinuousUnivariateDistribution, df::AbstractDataFrame; messages::Integer=nsteps÷100, scalingmessages::Bool=true)</code></pre><p>Same as the other method, but now with data <code>df</code> in the DICE 2 format: It should contain exactly four columns, the first one contains the number of ancestral reads, the second the number of derived reads, the third the frequency of the derived allele in the anchor population and the fourth the number of loci with exactly this combination of data. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L708-L712">source</a></section><section><div><pre><code class="language-julia hljs">MCMCsampler(nchains::Integer, nsteps::Integer, prioronn::DiscreteUnivariateDistribution, prioronτCτA::ContinuousMultivariateDistribution, prioronϵ::ContinuousUnivariateDistribution, dicefile::IO; messages::Integer=nsteps÷100, scalingmessages::Bool=true, header::Bool=true)</code></pre><p>Same as the other method, but with dicefile an opened CSV-file in DICE 2 format, as decribed above.</p><p>If you have Julia 1.3 or higher, and the file is a zipped file, open it using a zip decompressor:</p><pre><code class="language-julia hljs">using CodecZlib
dicefile = GzipDecompressorStream(open(&quot;path/to/your/file.csv.gz&quot;))</code></pre><p>With the named argument &quot;header&quot; one should indicate whether the CSV file has a header. The default is true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L722-L734">source</a></section><section><div><pre><code class="language-julia hljs">MCMCsampler(nchains::Integer, nsteps::Integer, prioronn::DiscreteUnivariateDistribution, prioronτCτA::ContinuousMultivariateDistribution, prioronϵ::ContinuousUnivariateDistribution, dicefile::AbstractString; messages::Integer=nsteps÷100, scalingmessages::Bool=true, header::Union{Nothing, Bool}=nothing)</code></pre><p>Same as the other methods, except that dicefile is a path to a (gzipped) CSV-file in DICE 2 format, as decribed above. </p><p>WARNING: If you work with gzipped files, Julia 1.3 or higher is required. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L741-L747">source</a></section><section><div><pre><code class="language-julia hljs">MCMCsampler(nchains::Integer, nsteps::Integer, prioronn::DiscreteUnivariateDistribution, prioronτCτA::ContinuousMultivariateDistribution, prioronϵ::ContinuousUnivariateDistribution, sedimentdata::Union{AbstractString, IO}, frequencies::Union{AbstractString, IO}; messages::Integer=nsteps÷100, scalingmessages::Bool=true, headersedimentdata::Union{Nothing, Bool}=nothing, headerfrequencies::Union{Nothing, Bool}=nothing)</code></pre><p>sedimentdata is a path to a (gzipped) CSV file, or an opened (gzipped) file, where the first column are the derived reads, and the second column are the coverages. frequencies is a path to a (gzipped) CSV file with one column, or an opened (gzipped) file with frequencies, containing frequencies of the anchor population. The number of rows of both files should be the same. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L754-L758">source</a></section><section><div><pre><code class="language-julia hljs">MCMCsampler(nchains::Integer, nsteps::Integer, prioronn::DiscreteUnivariateDistribution, prioronτCτA::ContinuousMultivariateDistribution, prioronϵ::ContinuousUnivariateDistribution, sedimentdata::DataFrame, frequencies::DataFrame; messages::Integer=nsteps÷100, scalingmessages::Bool=true)</code></pre><p>sedimentdata is a path to a DataFrame, where the first column are the derived reads, and the second column are the coverages. frequencies is a DataFrame with one column, containing frequencies of the anchor population. The number of rows of both files should be the same.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L765-L769">source</a></section></article><h2 id="unpackposterior"><a class="docs-heading-anchor" href="#unpackposterior">unpackposterior</a><a id="unpackposterior-1"></a><a class="docs-heading-anchor-permalink" href="#unpackposterior" title="Permalink"></a></h2><p>This function is used to build the unconditional posterior from the MCMC samples conditioned on n, as described in the paper. It has two methods. </p><p>Arguments:</p><ul><li><code>nsteps</code> is the number of MCMC samples, a positive integer. </li><li><code>chains</code> this the tuple that is the output of <code>MCMCsampler</code>. </li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Charon.unpackposterior" href="#Charon.unpackposterior"><code>Charon.unpackposterior</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unpackposterior(nsteps::Integer, chains::AbstractVector{&lt;:Tuple{AbstractVector{&lt;:Integer}, AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}, AbstractMatrix{Bool}, AbstractMatrix{&lt;:Real}}})</code></pre><p>Calculate the unconditional posterior from the output of MCMCsampler. <code>chains</code> is the output of the sampler, <code>nsteps</code> is the number of MCMC samples. This function returns a DataFrame containing nsteps rows, and 7 columns:</p><ul><li><code>nsample</code> sample for the number of individuals.</li><li><code>τCsample</code> sample for τC. </li><li><code>τAsample</code> sample for τA.</li><li><code>ϵsample</code> sample for ϵ. </li><li><code>accepted</code> Was any of the conditioned MCMC sample proposals, or the proposal for n accepted at step i?</li><li><code>logjointprob</code> the log joint probability up to a constant not depending on the parameters. </li><li><code>chainid</code> the id of the chain. A number 1,...,nchains. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L778-L789">source</a></section><section><div><pre><code class="language-julia hljs">unpackposterior(chains::AbstractVector{&lt;:Tuple{AbstractVector{&lt;:Integer}, AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}, AbstractMatrix{Bool}, AbstractMatrix{&lt;:Real}}})</code></pre><p>Calculate the unconditional posterior from the output of MCMCsampler. <code>chains</code> is the output of the sampler. The number of samples is determined from <code>chains</code>. The output is the same as the other method. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L828-L832">source</a></section></article><h2 id="exactposterior"><a class="docs-heading-anchor" href="#exactposterior">exactposterior</a><a id="exactposterior-1"></a><a class="docs-heading-anchor-permalink" href="#exactposterior" title="Permalink"></a></h2><p><code>exactposterior</code> is a function to calculate the posterior up to a fixed constant, only depending on the data, but not on the parameters. You can use this function for maximum posterior estimation. If you use uniform priors, you can use this function for maximum likelihood estimation. <code>MCMCsampler</code> uses this function to find a good starting point for the sampler. It has two methods. </p><p>The posterior is calculated for each combination of parameters (n, τC, τA, ϵ) with n in <code>nrange</code>, τC in <code>τCrange</code>, τA in <code>τArange</code> and ϵ in <code>ϵrange</code>. So make sure that <code>length(nrange)*length(τCrange)*length(τArange)*length(ϵrange)</code> is not too large, as otherwise it will take a very long time and you might run out of memory. </p><p>Parameters:</p><ul><li><code>nrange</code> vector of n values. Subtype of AbstractVector{&lt;:Integer}. Should be a subset of {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}. </li><li><code>τCrange</code> vector of τC values. Subtype of AbstractVector{&lt;:Real}. All values should be non-negative. </li><li><code>τArange</code> vector of τA values. Subtype of AbstractVector{&lt;:Real}. All values should be non-negative. </li><li><code>ϵrange</code> vector of ϵ values. Is a subtype of AbstractVector{&lt;:Real}. All values should be non-negative and smaller than 0.5. </li><li><code>coverages</code> a vector with coverages = ancestral reads + derived reads. Is a subtype of <code>AbstractVector{&lt;:Integer}</code>. All coverages should be non-negative integers, and at least one should be positive.</li><li><code>uniquecoverages</code> should be equal to <code>unique(coverages)</code>.  </li><li><code>derivedreads</code> a vector of derived reads. Is a subtype of <code>AbstractVector{&lt;:Integer}</code>. All elements of the vector should be non-negative integers.</li><li><code>frequencies</code> a vector of frequencies. Is a subtype of AbstractVector{&lt;:Real}. Each frequency is between 0.0 and 1.0. At least one frequency should be strictly between 0.0 and 1.0 with corresponding positive coverage. </li><li><code>counts</code>, all elements should be non-negative. For each index, <code>counts[index]</code> indicates how many loci there are with <code>derivedreads[index]</code> derived reads, coverage <code>coverages[index]</code> and frequency <code>frequencies[index]</code>. </li></ul><p>Keyword argument. </p><ul><li><code>messages</code> is an integer. If <code>messages</code> is non-positive, no message will be printed. If <code>messages</code> is positive, every <code>messages</code> steps a message will be printed with the progress of the calculations. </li></ul><p>The output are 5 vectors: <code>ns, τCs, τAs, ϵs, logliks</code>, of each of length <code>length(n)*length(τCrange)*length(τArange)*length(ϵrange)</code>, where <code>logliks[index]</code> is the log likelihood, up to an additive constant, with parameters <code>ns[index]</code>, <code>τCs[index]</code>, <code>τAs[index]</code> and <code>ϵs[index]</code>. The additive constant only depends on the data, but not on the parameters. </p><h3 id="Maximum-posterior-estimation-(MAP-estimator)"><a class="docs-heading-anchor" href="#Maximum-posterior-estimation-(MAP-estimator)">Maximum posterior estimation (MAP estimator)</a><a id="Maximum-posterior-estimation-(MAP-estimator)-1"></a><a class="docs-heading-anchor-permalink" href="#Maximum-posterior-estimation-(MAP-estimator)" title="Permalink"></a></h3><p>Suppose you have results</p><pre><code class="language-julia hljs">ns, τCs, τAs, ϵs, logliks = exactposterior(args...) </code></pre><p>where <code>args</code> are your arguments (data and priors, etc.). Then you can calculate the index where the log likelihood is maximised:</p><pre><code class="language-julia hljs">i_max = argmax(logliks)</code></pre><p>So </p><pre><code class="nohighlight hljs">ns[i_max], τCs[i_max], τAs[i_max], ϵs[i_max]</code></pre><p>is the MAP estimator. If you provide uniform priors, then the MAP estimator is a maximum likelihood estimator, where you maximise over the domain of the prior. </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Charon.exactposterior" href="#Charon.exactposterior"><code>Charon.exactposterior</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exactposterior(nrange::AbstractVector{&lt;:Integer}, τCrange::AbstractVector{&lt;:Real}, τArange::AbstractVector{&lt;:Real}, ϵrange::AbstractVector{&lt;:Real}, coverages::AbstractVector{&lt;:Integer}, uniquecoverages::AbstractVector{&lt;:Integer}, derivedreads::AbstractVector{&lt;:Integer}, frequencies::AbstractVector{&lt;:Real}, counts::AbstractVector{&lt;:Integer}; messages::Integer=0)</code></pre><p>Calculate the posterior for every combination of parameters (n, τC, τA, ϵ) where n is in <code>nrange</code>, τC is in <code>τCrange</code>, τA is in <code>τArange</code> and ϵ is in <code>ϵrange</code>. This function returns vectors <code>ns, τCs, τAs, ϵs, logliks</code>.  So the log posterior with <code>ns[i]</code> individuals, drift parameters <code>τCs[i]</code> and <code>τAs[i]</code> and error rates <code>ϵs[i]</code> is <code>logliks[i]</code>. The vectors are of length <code>length(n)*length(τCrange)*length(τArange)*length(ϵrange)</code>. Make sure that this is not too large, as otherwise the calculation might take very long time, or you might run out of memory. </p><p><code>coverages</code>, <code>derivedreads</code>, <code>frequencies</code>, and <code>counts</code> are the data. So there are <code>counts[i]</code> loci with coverage <code>coverages[i]</code>, <code>derivedreads[i]</code> derived reads and frequency <code>frequencies[i]</code> in the anchor population. <code>uniquecoverages=unique(coverages)</code>.</p><p><code>messages</code> is an integer. If it is positive, every <code>message</code> step an update is printed about the progress. If <code>messages</code> is non-positive, no update will be printed. </p><p>The output are four vectors <code>ns, τCs, τAs, ϵs, logliks</code>. For each index <code>logliks[i]</code> is the log likelihood with <code>ns[i]</code> individuals, drift parameters <code>τCs[i]</code> and <code>τAs[i]</code> and error rate <code>ϵs[i]</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L334-L344">source</a></section><section><div><pre><code class="language-julia hljs">exactposterior(nrange::AbstractVector{&lt;:Integer}, τCrange::AbstractVector{&lt;:Real}, τArange::AbstractVector{&lt;:Real}, ϵrange::AbstractVector{&lt;:Real}, coverages::AbstractVector{&lt;:Integer}, derivedreads::AbstractVector{&lt;:Integer}, frequencies::AbstractVector{&lt;:Real}; messages::Integer=length(n)*length(τCrange)*length(τArange)*length(ϵrange)÷100)</code></pre><p>A user-friendly function to calculate the log posterior. The input are data in the form of three vectors: <code>coverages</code>, <code>derivedreads</code> and <code>frequencies</code>. This is the data for all loci. So at locus i, the coverage is <code>coverages[i]</code>, the number of derived reads is <code>derivedreads[i]</code> and the frequency in the anchor population is <code>frequencies[i]</code>. The other parameters are the same as in the other method.</p><p>The output is the same as the other method. The default value for <code>messages</code> is <code>length(n)*length(τCrange)*length(τArange)*length(ϵrange)÷100)</code>, so every 1% progress an update is printed. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L411-L417">source</a></section></article><h2 id="Charon-EigenExpansion-type"><a class="docs-heading-anchor" href="#Charon-EigenExpansion-type">Charon EigenExpansion type</a><a id="Charon-EigenExpansion-type-1"></a><a class="docs-heading-anchor-permalink" href="#Charon-EigenExpansion-type" title="Permalink"></a></h2><p>This type is not exported, but can be used after <code>using Charon: EigenExpansion</code>, or via <code>Charon.EigenExpansion</code>. It represents a matrix decomposition <span>$M=P*D*P^{-1}$</span>, where <span>$P$</span> is an invertible matrix with inverse <span>$P^{-1}$</span>, and <span>$D$</span> is a diagonal matrix. It is used to efficiently calculate the exponent of a matrix. </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Charon.EigenExpansion" href="#Charon.EigenExpansion"><code>Charon.EigenExpansion</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EigenExpansion{Q&lt;:AbstractMatrix{&lt;:Real}, R&lt;:Real, S&lt;:AbstractVector{R}, T&lt;:AbstractMatrix{&lt;:Real}}</code></pre><p>Representation of a matrix decomposition <code>M=P*D*P^{-1}</code>, where D is a diagonal matrix and P an invertible matrix with inverse Pinv.</p><p>This decomposition can be used for fast matrix exponentiation, using that <code>exp(M) = P*exp(D)*Pinv</code>, and the fact that the exponent of a diagonal matrix is formed by exponentiating its diagonal elements.</p><p>Fields:</p><pre><code class="language-julia hljs">P::Q 
D::Diagonal{R, S}
Pinv::T </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L27-L40">source</a></section></article><h2 id="Internal,-non-exported-functions"><a class="docs-heading-anchor" href="#Internal,-non-exported-functions">Internal, non-exported functions</a><a id="Internal,-non-exported-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Internal,-non-exported-functions" title="Permalink"></a></h2><p>The following functions are not exported, and only available via <code>Charon.functionname</code>, or <code>using Charon: functionname</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Charon.calcloglik" href="#Charon.calcloglik"><code>Charon.calcloglik</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calcloglik(coverages::AbstractVector{&lt;:Integer}, derivedreads::AbstractVector{&lt;:Integer}, counts::AbstractVector{&lt;:Integer}, M::AbstractMatrix{&lt;:Real}, hvals::AbstractMatrix{&lt;:Real}, q::AbstractDict{&lt;:Tuple{Integer, Integer}, &lt;:AbstractVector{&lt;:Real}}, index::Integer)</code></pre><p>Calculate the log-likelihood of the data at index <code>index</code>.  Parameters:</p><ul><li><code>coverages</code> vector with coverages.</li><li><code>derivedreads</code> vector with derived reads.</li><li><code>counts</code> <code>counts[i]</code> loci have <code>coverages[i]</code> coverage and <code>derivedreads[i]</code> derived reads. </li><li><code>M=e^{Q*τA}e^{QꜜτC}</code>, where <code>τC</code> and <code>τA</code> are the drift parameters, Q and Qꜜ are the matrices as in Schraiber 2018, and M is calculated with <code>calcmatrix</code>.</li><li><code>hvals</code> the matrix constructed with <code>preparedata</code>, see the documentation of <code>preparedata</code>.</li><li><code>q</code> the dictionary made with <code>makeq</code>.</li><li><code>index</code> the index of the data we are working on. </li></ul><p>This function returns a real number. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L287-L301">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Charon.calcmatrix" href="#Charon.calcmatrix"><code>Charon.calcmatrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calcmatrix(τC::Real, τA::Real, Qꜜ::EigenExpansion, Q::EigenExpansion)</code></pre><p>Calculate the matrix <code>e^{Q*τ_A}e^{Qꜜτ_C}</code> as in Schraiber. Note that in general, for matrices, exp(A+B) ≠ exp(A)exp(B) (equality holds if and only if A and B commute, which is not the case for Q and Qꜜ). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L152-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Charon.filtervectorsandapplycountmap" href="#Charon.filtervectorsandapplycountmap"><code>Charon.filtervectorsandapplycountmap</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">filtervectorsandapplycountmap(coverages::AbstractVector{&lt;:Integer}, derivedreads::AbstractVector{&lt;:Integer}, frequencies::AbstractVector{&lt;:Real}, allowedindices::AbstractVector{Bool})</code></pre><p>This function does the following:</p><pre><code class="language-julia hljs">coverages_filtered = coverages[allowedindices]
derivedreads_filtered = derivedreads[allowedindices]
frequencies_filtered = frequencies[allowedindices]</code></pre><p>Next, it counts how many times <code>(coverages_filtered[i], derivedreads_filtered[i], frequencies_filtered[i])</code> occurs, for all triples, and next returns four vectors <code>(coverages_filtered_unique, derivedreads_filtered_unique, frequencies_filtered_unique, counts)</code>, where each triple <code>(coverages_filtered_unique[i], derivedreads_filtered_unique[i], frequencies_filtered_unique[i])</code> is unique and occurs <code>counts[i]</code> times in <code>zip(coverages_filtered, derivedreads_filtered, frequencies_filtered)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L216-L227">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Charon.logprobderivedreads!" href="#Charon.logprobderivedreads!"><code>Charon.logprobderivedreads!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">logprobderivedreads!(q::AbstractDict{&lt;:Tuple{Integer, Integer}, &lt;:AbstractVector{&lt;:Real}}, n::Integer, τC::Real, τA::Real, ϵ::Real, coverages::AbstractVector{&lt;:Integer}, uniquecoverages::AbstractVector{&lt;:Integer}, derivedreads::AbstractVector{&lt;:Integer}, counts::AbstractVector{&lt;:Integer}, Qꜜ::EigenExpansion, Q::EigenExpansion, binomialcoefficients::AbstractVector{&lt;:Integer}, hvals::AbstractMatrix{&lt;:Real})</code></pre><p>Calculate the log probability of the data, a.k.a. the likelihood. q is mutated with the function <code>updateq!</code>. <code>q</code> is a dictionary, and is used for intermediate calculations. </p><p>Parameters: </p><ul><li><code>n</code> number of individuals.</li><li><code>τC</code> and <code>τA</code> drift parameters.</li><li><code>ϵ</code> error rate. </li></ul><p>Data:</p><ul><li><code>coverages</code> the coverages.</li><li><code>uniquecoverages=unique(coverages)</code></li><li><code>derivedreads</code> vector with the derived reads.</li><li><code>counts</code> in <code>counts[i]</code> loci there are <code>coverages[i]</code> coverage and <code>derivedreads[i]</code> derived reads. </li></ul><p>Other data:</p><ul><li><code>Qꜜ</code> the matrix Qꜜ as in Schraiber 2018.</li><li><code>Q</code> the matrix Q as in Schraiber 2018.</li><li><code>binomialcoefficients</code> vector of length 2n+1, where entry k+1 is the binomial coefficient of 2n over k. Note that Julia is 1-based.</li><li><code>hvals</code> the matrix as constructed with the function <code>preparedata</code>. See documentation for <code>preparedata</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L181-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Charon.makeq" href="#Charon.makeq"><code>Charon.makeq</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">makeq(nmax::Integer, coverages::AbstractVector{&lt;:Integer}, derivedreads::AbstractVector{&lt;:Integer})</code></pre><p>Construct a vector of length nmax, where the n-th item is a dictionary with keys (coverages[i], derivedreads[i]) and values real vectors of length 2n+1. The vectors contain arbitrary data. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L259-L263">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Charon.makeqfixedn" href="#Charon.makeqfixedn"><code>Charon.makeqfixedn</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">makeqfixedn(n::Integer, uniquecoveragesandderivedreads::AbstractVector{&lt;:Tuple{Integer, Integer}})</code></pre><p>Construct a dictionary with keys <code>uniquecoveragesandderivedreads[i]</code> (which is a tuple where the first element is the coverage and the second is the number of derived reads) and values real vectors of length 2n+1. The values in the vectors are arbitrary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L242-L246">source</a></section><section><div><pre><code class="language-julia hljs">makeqfixedn(n::Integer, coverages::AbstractVector{&lt;:Integer}, derivedreads::AbstractVector{&lt;:Integer})</code></pre><p>Construct a dictionary with keys <code>(coverages[i], derivedreads[i])</code> and values real vectors of length 2n+1. The values in the vectors are arbitrary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L249-L253">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Charon.makeQ" href="#Charon.makeQ"><code>Charon.makeQ</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">makeQ(n::Integer)</code></pre><p>Calculate the (2n+1)x(2n+1) tridiagonal matrix Q as in Schraiber 2018. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L128-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Charon.makeQꜜ" href="#Charon.makeQꜜ"><code>Charon.makeQꜜ</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">makeQꜜ(n::Integer)</code></pre><p>Calculate the (2n+1)x(2n+1) tridiagonal matrix Qꜜ as in Schraiber 2018.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L140-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Charon.preparedata" href="#Charon.preparedata"><code>Charon.preparedata</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">preparedata(n::Integer, frequencies::AbstractVector{&lt;:Real})</code></pre><p>Returns a named tuple <code>(Qꜜ=Qꜜ, Q=Q, binomialcoefficients=binomialcoefficients, hvals=hvals)</code>, where  Qꜜ and Q are EigenExpansions of Qꜜ and Q (as in Schraiber 2018), respectively.  hvals is a (2n+1) x length(y) matrix of type SizedMatrix. SizedMatrix is used rather than SMatrix because this matrix is so large and  SMatrix is slow for large matrices. The matrix hvals is defined as hvals[k+1,i] = frequencies[i]^k*(1-frequencies[i])^(2n-k) (note that Julia has 1-based indexing). binomialcoefficients is a vector of length 2n+1 (of type SVector) containing the binomial coefficients 2n over k, k=0,...,2n.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L159-L167">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Charon.readcsvfile" href="#Charon.readcsvfile"><code>Charon.readcsvfile</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">readcsvfile(filename::AbstractString, header::Union{Nothing, Bool})</code></pre><p>Read CSV file and turn it into a DataFrame (from DataFrames package). If header=nothing, it automatically detects whether the CSV file has a header. </p><p>WARNING: this function assumes that the data in the first column does not contain Strings, otherwise it might wrongly infer that the file has a header, so you will miss one row of data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L304-L310">source</a></section><section><div><pre><code class="language-julia hljs">readcsvfile(filename::IO, header::Bool)</code></pre><p>Read the opened CSV file. <code>header</code> indicates whether the file has a header. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L327-L331">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Charon.updateq!" href="#Charon.updateq!"><code>Charon.updateq!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">updateq!(q::AbstractDict{&lt;:Tuple{Integer, Integer}, &lt;:AbstractVector{&lt;:Real}}, n::Integer, ϵ::Real, uniquecoverages::AbstractVector{&lt;:Integer}, binomialcoefficients::AbstractVector{&lt;:Integer})</code></pre><p>Update the dictionary <code>q</code><code>, so that</code>q[(R, d)][k+1]<code>is the probability of d derived reads out of R when you have k derived alleles with</code>n<code>inidividuals and error rate</code>ϵ<code>.</code>uniquecoverages<code>are all unique occurences of coverages in the data.</code>binomialcoefficients` is a vector of length 2n+1, with k+1-th entry equal to the binomial coefficients of 2n over k. Note that Julia has 1-based indexing.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L269-L273">source</a></section></article><h2 id="Extended-Julia-base-functions."><a class="docs-heading-anchor" href="#Extended-Julia-base-functions.">Extended Julia base functions.</a><a id="Extended-Julia-base-functions.-1"></a><a class="docs-heading-anchor-permalink" href="#Extended-Julia-base-functions." title="Permalink"></a></h2><p>I extended several Julia base functions to my custom EigenExpansion type. </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.exp" href="#Base.exp"><code>Base.exp</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exp(s::Real, F::EigenExpansion)</code></pre><p>Calculate <code>e^(s*M)</code> in a numerically efficient way. </p><p>If <code>F=EigenExpansion(M)</code>, then <code>exp(s*M)=exp(s, F)=F.P*exp(s*F.D)*F.Pinv</code>, which makes  use of the fast implementation of exp for diagonal matrices (it is just the exponentiation of the diagonal elements).     </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L118-L125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.show" href="#Base.show"><code>Base.show</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.show(io::IO, mime::MIME{Symbol(&quot;text/plain&quot;)}, F::EigenExpansion{Q, R, S, T}) where {Q&lt;:AbstractMatrix{&lt;:Real}, R&lt;:Real, S&lt;:AbstractVector{R}, T&lt;:AbstractMatrix{&lt;:Real}}</code></pre><p>Pretty display of <code>EigenExpansion</code> types. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L97-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:==" href="#Base.:=="><code>Base.:==</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">==(E1::EigenExpansion, E2::EigenExpansion)</code></pre><p>Test whether <code>E1</code> and <code>E2</code> have the same decomposition <code>P*D*P^(-1)</code>, so whether <code>E1.P == E2.P</code>, <code>E1.D == E2.D</code> and <code>E1.Pinv == E2.Pinv</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jan-van-Waaij/Charon.jl/blob/v0.3.2/src/Charon.jl#L111-L115">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../guide/">« Getting started</a><a class="docs-footer-nextpage" href="../allfunctions/">Index »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Friday 2 May 2025 08:54">Friday 2 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
